{"mappings":";;;;;;;AEQA,MAAM,qCAAe;IACnB,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,KAAK;IACL,KAAK;IACL,IAAI;IACJ,KAAK;IACL,UAAU;IACV,WAAW;IACX,WAAW;IACX,YAAY;IACZ,SAAS;IACT,UAAU;IACV,MAAM;IACN,OAAO;IACP,YAAY;IACZ,aAAa;IACb,aAAa;IACb,cAAc;IACd,UAAU;IACV,WAAW;IACX,WAAW;IACX,YAAY;IACZ,IAAI;IACJ,KAAK;AACP;AAEO,MAAM,4CAAwB,CAAC,IACpC,OAAO,EAAE,QAAQ,KAAK,YACtB,OAAO,EAAE,OAAO,KAAK,aACrB,OAAO,EAAE,GAAG,KAAK,YACjB,OAAO,EAAE,MAAM,KAAK;AAEf,MAAM,4CAAc,CAAC,IAAuC,CAAA;QACjE,SAAS,EAAE,OAAO;QAClB,YAAY,EAAE,MAAM;QACpB,QAAQ,OAAO,IAAI,CAAC,EAAE,QAAQ,CAAC,IAAI,EAAE,MAAM,CACzC,CAAC,KAAK,OAAU,CAAA;gBACd,GAAG,GAAG;gBACN,CAAC,KAAK,EAAE,AAAC,EAA0B,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO;YAChE,CAAA,GACA,CAAC;IAEL,CAAA;AAEA,MAAM,4CAAsB,CAAC,SAC3B,OAAO,QAAQ,KAAK,SAAS,OAAO,QAAQ,KAAK;AAE5C,MAAM,2CAA0B,CACrC,SACA,eAA8C,KAAK,EACnD,MAAM,CAAC,GAEP,QACG,GAAG,CAAC,CAAC,QAAQ,IACZ,0CAAoB,UAChB,CAAC,CAAC,EAAE,yCAAwB,OAAO,KAAK,EAAE,OAAO,QAAQ,EAAE,GAAG,CAAC,CAAC,GAChE,CAAC,EAAE,OAAO,KAAK,CAAC,CAAC,EAAE,kCAAY,CAAC,OAAO,QAAQ,CAAC,CAAC,GAAG,EAClD,OAAO,KAAK,CACb,EAAE,IAAI,EAAE,EAAE,CAAC,CAAC,EAElB,IAAI,CAAC,CAAC,CAAC,EAAE,kCAAY,CAAC,aAAa,CAAC,CAAC,CAAC;AAEpC,MAAM,4CAAsB,CACjC,SACA,MAAM,CAAC,GAEP,QAAQ,MAAM,CACZ,CAAC,KAAK,QAAQ,IAAO,CAAA;YACnB,GAAG,GAAG;YACN,GAAI,0CAAoB,UACpB,0CAAoB,OAAO,KAAK,EAAE,KAClC;gBAAE,CAAC,OAAO,KAAK,GAAG,MAAM,EAAE,EAAE,OAAO,KAAK;YAAC,CAAC;QAChD,CAAA,GACA,CAAC;;;AD9CL,MAAM,uCAAsC;IAC1C,YAAY;IACZ,qBAAqB;AACvB;AAEA,MAAM,4CAAsB,CAAC,IAC3B,OAAO,EAAE,YAAY,KAAK;AAErB,MAAM,4CAAe,CAC1B,IACA;IAEA,MAAM,UAA6C;QACjD,GAAG,oCAAc;QACjB,GAAG,WAAW;IAChB;IAEA,OAAO;QACL,UAAU,OAAO,SAAE,KAAK,YAAE,QAAQ,YAAE,QAAQ,QAAE,IAAI,EAAE;YAClD,IAAI;gBACF,MAAM,GAAG,UAAU,CAAC,QAAQ,UAAU,EAAE,MAAM,CAC5C;2BACE;8BACA;0BACA;8BACA;oBACA,iBAAiB;gBACnB,GACA;oBAAE,YAAY;gBAAK;gBAGrB,IAAI,QAAQ,mBAAmB,EAC7B,MAAM,GACH,UAAU,CAAC,QAAQ,UAAU,EAC7B,mBAAmB,CAAC,OAAO;oBAAE,YAAY;gBAAK;gBAEnD,OAAO;oBACL,SAAS;oBACT,YAAY,QAAQ,kBAAkB;gBACxC;YACF,EAAE,OAAO,KAAK;gBACZ,OAAO;oBACL,SAAS;oBACT,OAAO,CAAA,GAAA,yCAAoB,EAAE,OAAO,CAAA,GAAA,yCAAU,EAAE,OAAO;oBACvD,YAAY,QAAQ,uBAAuB;gBAC7C;YACF;QACF;QACA,gBAAgB,OAAO,SAAE,KAAK,EAAE;YAC9B,IAAI;gBACF,MAAM,GACH,UAAU,CAAC,QAAQ,UAAU,EAC7B,oBAAoB,CAAC,OAAO;oBAAE,YAAY;gBAAK;gBAElD,OAAO;oBACL,SAAS;oBACT,YAAY,QAAQ,wBAAwB;gBAC9C;YACF,EAAE,OAAO,KAAK;gBACZ,OAAO;oBACL,SAAS;oBACT,OAAO,CAAA,GAAA,yCAAoB,EAAE,OAAO,CAAA,GAAA,yCAAU,EAAE,OAAO;oBACvD,YAAY,QAAQ,6BAA6B;gBACnD;YACF;QACF;QACA,gBAAgB,OAAO,SAAE,KAAK,YAAE,QAAQ,mBAAE,eAAe,EAAE;YACzD,IAAI;gBACF,MAAM,GACH,UAAU,CAAC,QAAQ,UAAU,EAC7B,oBAAoB,CAAC,OAAO,UAAU,iBAAiB;oBACtD,YAAY;gBACd;gBAEF,OAAO;oBACL,SAAS;oBACT,YAAY,QAAQ,wBAAwB;gBAC9C;YACF,EAAE,OAAO,KAAK;gBACZ,OAAO;oBACL,SAAS;oBACT,OAAO,CAAA,GAAA,yCAAoB,EAAE,OAAO,CAAA,GAAA,yCAAU,EAAE,OAAO;oBACvD,YAAY,QAAQ,6BAA6B;gBACnD;YACF;QACF;QACA,OAAO,OAAO;YACZ,IAAI;gBACF,IAAI,0CAAoB,eAAe;oBACrC,MAAM,GACH,UAAU,CAAC,QAAQ,UAAU,EAC7B,cAAc,CAAC;wBAAE,UAAU,aAAa,YAAY;oBAAC;oBACxD,IAAI,GAAG,SAAS,CAAC,OAAO,EACtB,OAAO;wBACL,SAAS;wBACT,YAAY,QAAQ,eAAe;oBACrC;gBAEJ,OAAO;oBACL,MAAM,GACH,UAAU,CAAC,QAAQ,UAAU,EAC7B,gBAAgB,CAAC,aAAa,KAAK,EAAE,aAAa,QAAQ,EAAE;wBAC3D,YAAY;oBACd;oBACF,IAAI,GAAG,SAAS,CAAC,OAAO,EACtB,OAAO;wBACL,SAAS;wBACT,YAAY,QAAQ,eAAe;oBACrC;gBAEJ;YACF,EAAE,OAAO,KAAK;gBACZ,OAAO;oBACL,SAAS;oBACT,OAAO,CAAA,GAAA,yCAAoB,EAAE,OAAO,CAAA,GAAA,yCAAU,EAAE,OAAO;oBACvD,YAAY,QAAQ,oBAAoB;gBAC1C;YACF;YACA,OAAO;gBACL,SAAS;gBACT,OAAO;oBACL,MAAM;oBACN,SAAS;gBACX;YACF;QACF;QACA,QAAQ;YACN,GAAG,SAAS,CAAC,KAAK;YAClB,OAAO;gBACL,SAAS;gBACT,YAAY,QAAQ,gBAAgB;YACtC;QACF;QACA,OAAO;YACL,IAAI,GAAG,SAAS,CAAC,OAAO,EACtB,OAAO;gBACL,eAAe;gBACf,YAAY,QAAQ,uBAAuB;YAC7C;YAGF,OAAO;gBACL,eAAe;gBACf,YAAY,QAAQ,yBAAyB;YAC/C;QACF;QACA,gBAAgB,UAAY;QAC5B,aAAa;YACX,IAAI,GAAG,SAAS,CAAC,OAAO,IAAI,GAAG,SAAS,CAAC,KAAK,EAAE;gBAC9C,MAAM,MAAE,EAAE,QAAE,IAAI,UAAE,MAAM,EAAE,GAAG,GAAG,SAAS,CAAC,KAAK;gBAC/C,OAAO;wBACL;0BACA;4BACA;gBACF;YACF;YACA,OAAO;QACT;QACA,SAAS,OAAO;YACd,OAAO;uBAAE;YAAM;QACjB;IACF;AACF;;;;;;;AEzLO,MAAM,4CAAe,CAC1B,KAII,CAAA;QACJ,SAAS,OAAO,YAAE,QAAQ,cAAE,UAAU,WAAE,OAAO,WAAE,OAAO,EAAE;YACxD,MAAM,WAAE,UAAU,aAAG,WAAW,UAAI,OAAO,UAAU,GAAG,cAAc,CAAC;YAEvE,MAAM,OAAO,SACT,IAAI,CAAC,IAAM,CAAC,EAAE,EAAE,KAAK,KAAK,SAAS,MAAM,GAAG,EAAE,EAAE,KAAK,CAAC,CAAC,EACxD,KAAK;YAER,MAAM,SAAS,UACX,GAAG,MAAM,CACP,CAAA,GAAA,wCAAsB,EAAE,UACxB,CAAA,GAAA,yCAAkB,EAAE,YAEtB;YAEJ,MAAM,aAAa,GAAG,UAAU,CAAC;YAEjC,IAAI;gBACF,IAAI,SAAS,UAAU;oBACrB,MAAM,SAAE,KAAK,cAAE,UAAU,EAAE,GAAG,MAAM,WAAW,OAAO,CACpD,SACA,UACA;wBACE,GAAI,OAAO;kCAAE;wBAAK,IAAI,CAAC,CAAC;wBACxB,GAAI,SAAS;oCAAE;wBAAO,IAAI,CAAC,CAAC;wBAC5B,YAAY;oBACd;oBAGF,OAAO;wBACL,MAAM;wBACN,OAAO;oBACT;gBACF,OAAO;oBACL,MAAM,QAAQ,MAAM,WAAW,WAAW,CAAC;8BACzC;gCACA;wBACA,YAAY;oBACd;oBAEA,OAAO;wBACL,MAAM;wBACN,OAAO,MAAM,MAAM;oBACrB;gBACF;YACF,EAAE,OAAO,GAAY;gBACnB,IAAI,CAAA,GAAA,yCAAoB,EAAE,IACxB,MAAM,CAAA,GAAA,yCAAU,EAAE;gBAEpB,MAAM;YACR;QACF;QAEA,QAAQ,OAAO,YAAE,QAAQ,aAAE,SAAS,EAAE;YACpC,IAAI;gBACF,MAAM,OAAO,MAAM,GAChB,UAAU,CAAC,UACX,MAAM,CAAC,WAAsC;oBAAE,YAAY;gBAAK;gBAEnE,OAAO;0BAAE;gBAAK;YAChB,EAAE,OAAO,GAAY;gBACnB,IAAI,CAAA,GAAA,yCAAoB,EAAE,IACxB,MAAM,CAAA,GAAA,yCAAU,EAAE;gBAEpB,MAAM;YACR;QACF;QAEA,QAAQ,OAAO,YAAE,QAAQ,MAAE,EAAE,aAAE,SAAS,EAAE;YACxC,IAAI;gBACF,MAAM,OAAO,MAAM,GAChB,UAAU,CAAC,UACX,MAAM,CAAC,IAAc,WAAsC;oBAC1D,YAAY;gBACd;gBAEF,OAAO;0BAAE;gBAAK;YAChB,EAAE,OAAO,GAAY;gBACnB,IAAI,CAAA,GAAA,yCAAoB,EAAE,IACxB,MAAM,CAAA,GAAA,yCAAU,EAAE;gBAEpB,MAAM;YACR;QACF;QAEA,QAAQ,OAAO,YAAE,QAAQ,MAAE,EAAE,EAAE;YAC7B,IAAI;gBACF,MAAM,OAAO,MAAM,GAChB,UAAU,CAAC,UACX,MAAM,CAAC,IAAc;oBAAE,YAAY;gBAAK;gBAE3C,OAAO;0BAAE;gBAAK;YAChB,EAAE,OAAO,GAAY;gBACnB,IAAI,CAAA,GAAA,yCAAoB,EAAE,IACxB,MAAM,CAAA,GAAA,yCAAU,EAAE;gBAEpB,MAAM;YACR;QACF;QAEA,WAAW,OAAO,YAAE,QAAQ,MAAE,EAAE,EAAE;YAChC,IAAI;gBACF,MAAM,UAAU,MAAM,GACnB,UAAU,CAAC,UACX,MAAM,CAAC,IAAc;oBAAE,YAAY;gBAAK;gBAE3C,OAAO;oBAAE,MAAM,UAAU;4BAAE;oBAAG,IAAI;gBAAU;YAC9C,EAAE,OAAO,GAAG;gBACV,IAAI,CAAA,GAAA,yCAAoB,EAAE,IACxB,MAAM,CAAA,GAAA,yCAAU,EAAE;gBAEpB,MAAM;YACR;QACF;QAEA,WAAW;YACT,OAAO,GAAG,OAAO;QACnB;IACF,CAAA;;;;;;ACvIO,MAAM,4CAAe,CAAC,KAAkC,CAAA;QAC7D,WAAW,CAAC,WAAE,OAAO,UAAE,MAAM,YAAE,QAAQ,EAAE;YACvC,OAAO,GACJ,UAAU,CAAC,QAAQ,OAAO,CAAC,cAAc,KACzC,SAAS,CAAC,QAAQ,IAAI,cAAc,KAAK,CAAC;gBACzC,MAAM,YAAuB;6BAC3B;oBACA,MAAM,IAAI;oBACV,SAAS,EAAE,MAAM;oBACjB,MAAM,EAAE,MAAM;gBAChB;gBAEA,SAAS;YACX;QACJ;QACA,aAAa,CAAC;YACZ,cAAc,IAAI,CAAC,CAAC,QAAU;QAChC;IACF,CAAA;","sources":["lib/src/index.ts","lib/src/authProvider.ts","lib/src/utils.ts","lib/src/dataProvider.ts","lib/src/liveProvider.ts"],"sourcesContent":["export * from \"./authProvider\";\nexport * from \"./dataProvider\";\nexport * from \"./liveProvider\";\n","import { AuthBindings, UpdatePasswordFormTypes } from \"@refinedev/core\";\nimport type PocketBase from \"pocketbase\";\nimport { isClientResponseError, toHttpError } from \"./utils\";\n\nexport interface LoginWithProvider {\n  providerName: string;\n}\nexport interface LoginWithPassword {\n  email: string;\n  password: string;\n  remember: boolean;\n}\n\nexport type LoginOptions = LoginWithProvider | LoginWithPassword;\n\nexport interface AuthOptions {\n  collection?: string;\n  requestVerification?: boolean;\n  registerRedirectTo?: string;\n  registerErrorRedirectTo?: string;\n  forgotPasswordRedirectTo?: string;\n  forgotPasswordErrorRedirectTo?: string;\n  updatePasswordRedirectTo?: string;\n  updatePasswordErrorRedirectTo?: string;\n  loginRedirectTo?: string;\n  loginErrorRedirectTo?: string;\n  logoutRedirectTo?: string;\n  authenticatedRedirectTo?: string;\n  unauthenticatedRedirectTo?: string;\n}\n\ntype RequiredAuthOptions = Pick<\n  Required<AuthOptions>,\n  \"collection\" | \"requestVerification\"\n>;\n\nexport type UpdatePasswordProps = UpdatePasswordFormTypes & { token: string };\n\nconst defaultOptions: RequiredAuthOptions = {\n  collection: \"users\",\n  requestVerification: false,\n};\n\nconst isLoginWithProvider = (x: any): x is LoginWithProvider =>\n  typeof x.providerName === \"string\";\n\nexport const authProvider = (\n  pb: PocketBase,\n  authOptions?: AuthOptions\n): AuthBindings => {\n  const options: RequiredAuthOptions & AuthOptions = {\n    ...defaultOptions,\n    ...authOptions,\n  };\n\n  return {\n    register: async ({ email, password, username, name }) => {\n      try {\n        await pb.collection(options.collection).create(\n          {\n            email,\n            username,\n            name,\n            password,\n            passwordConfirm: password,\n          },\n          { requestKey: null }\n        );\n\n        if (options.requestVerification) {\n          await pb\n            .collection(options.collection)\n            .requestVerification(email, { requestKey: null });\n        }\n        return {\n          success: true,\n          redirectTo: options.registerRedirectTo,\n        };\n      } catch (err) {\n        return {\n          success: false,\n          error: isClientResponseError(err) ? toHttpError(err) : undefined,\n          redirectTo: options.registerErrorRedirectTo,\n        };\n      }\n    },\n    forgotPassword: async ({ email }) => {\n      try {\n        await pb\n          .collection(options.collection)\n          .requestPasswordReset(email, { requestKey: null });\n\n        return {\n          success: true,\n          redirectTo: options.forgotPasswordRedirectTo,\n        };\n      } catch (err) {\n        return {\n          success: false,\n          error: isClientResponseError(err) ? toHttpError(err) : undefined,\n          redirectTo: options.forgotPasswordErrorRedirectTo,\n        };\n      }\n    },\n    updatePassword: async ({ token, password, confirmPassword }) => {\n      try {\n        await pb\n          .collection(options.collection)\n          .confirmPasswordReset(token, password, confirmPassword, {\n            requestKey: null,\n          });\n\n        return {\n          success: true,\n          redirectTo: options.updatePasswordRedirectTo,\n        };\n      } catch (err) {\n        return {\n          success: false,\n          error: isClientResponseError(err) ? toHttpError(err) : undefined,\n          redirectTo: options.updatePasswordErrorRedirectTo,\n        };\n      }\n    },\n    login: async (loginOptions: LoginOptions) => {\n      try {\n        if (isLoginWithProvider(loginOptions)) {\n          await pb\n            .collection(options.collection)\n            .authWithOAuth2({ provider: loginOptions.providerName });\n          if (pb.authStore.isValid) {\n            return {\n              success: true,\n              redirectTo: options.loginRedirectTo,\n            };\n          }\n        } else {\n          await pb\n            .collection(options.collection)\n            .authWithPassword(loginOptions.email, loginOptions.password, {\n              requestKey: null,\n            });\n          if (pb.authStore.isValid) {\n            return {\n              success: true,\n              redirectTo: options.loginRedirectTo,\n            };\n          }\n        }\n      } catch (err) {\n        return {\n          success: false,\n          error: isClientResponseError(err) ? toHttpError(err) : undefined,\n          redirectTo: options.loginErrorRedirectTo,\n        };\n      }\n      return {\n        success: false,\n        error: {\n          name: \"Login Error\",\n          message: \"Invalid email or password\",\n        },\n      };\n    },\n    logout: async () => {\n      pb.authStore.clear();\n      return {\n        success: true,\n        redirectTo: options.logoutRedirectTo,\n      };\n    },\n    check: async () => {\n      if (pb.authStore.isValid) {\n        return {\n          authenticated: true,\n          redirectTo: options.authenticatedRedirectTo,\n        };\n      }\n\n      return {\n        authenticated: false,\n        redirectTo: options.unauthenticatedRedirectTo,\n      };\n    },\n    getPermissions: async () => null,\n    getIdentity: async () => {\n      if (pb.authStore.isValid && pb.authStore.model) {\n        const { id, name, avatar } = pb.authStore.model;\n        return {\n          id,\n          name,\n          avatar,\n        };\n      }\n      return null;\n    },\n    onError: async (error) => {\n      return { error };\n    },\n  };\n};\n","import {\n  ConditionalFilter,\n  CrudFilter,\n  CrudFilters,\n  HttpError,\n} from \"@refinedev/core\";\nimport { ClientResponseError } from \"pocketbase\";\n\nconst OPERATOR_MAP = {\n  eq: \"=\",\n  ne: \"!=\",\n  lt: \"<\",\n  gt: \">\",\n  lte: \"<=\",\n  gte: \">=\",\n  in: \"?=\",\n  nin: \"?!=\",\n  contains: \"~\",\n  ncontains: \"!~\",\n  containss: \"~\",\n  ncontainss: \"!~\",\n  between: \"\",\n  nbetween: \"\",\n  null: \"=\",\n  nnull: \"!=\",\n  startswith: \"~\",\n  nstartswith: \"!~\",\n  startswiths: \"~\",\n  nstartswiths: \"!~\",\n  endswith: \"~\",\n  nendswith: \"!~\",\n  endswiths: \"~\",\n  nendswiths: \"!~\",\n  or: \"||\",\n  and: \"&&\",\n};\n\nexport const isClientResponseError = (x: any): x is ClientResponseError =>\n  typeof x.response === \"object\" &&\n  typeof x.isAbort === \"boolean\" &&\n  typeof x.url === \"string\" &&\n  typeof x.status === \"number\";\n\nexport const toHttpError = (e: ClientResponseError): HttpError => ({\n  message: e.message,\n  statusCode: e.status,\n  errors: Object.keys(e.response.data).reduce(\n    (acc, next) => ({\n      ...acc,\n      [next]: (e as ClientResponseError).response.data[next].message,\n    }),\n    {}\n  ),\n});\n\nconst isConditionalFilter = (filter: CrudFilter): filter is ConditionalFilter =>\n  filter.operator === \"and\" || filter.operator === \"or\";\n\nexport const extractFilterExpression = (\n  filters: CrudFilters,\n  joinOperator: ConditionalFilter[\"operator\"] = \"and\",\n  pos = 0\n) =>\n  filters\n    .map((filter, i): string =>\n      isConditionalFilter(filter)\n        ? `(${extractFilterExpression(filter.value, filter.operator, i)})`\n        : `${filter.field} ${OPERATOR_MAP[filter.operator]} {:${\n            filter.field\n          }${pos}${i}}`\n    )\n    .join(` ${OPERATOR_MAP[joinOperator]} `);\n\nexport const extractFilterValues = (\n  filters: CrudFilters,\n  pos = 0\n): Record<string, unknown> =>\n  filters.reduce(\n    (acc, filter, i) => ({\n      ...acc,\n      ...(isConditionalFilter(filter)\n        ? extractFilterValues(filter.value, i)\n        : { [filter.field + pos + i]: filter.value }),\n    }),\n    {}\n  );\n","import {\n  CreateResponse,\n  DataProvider,\n  GetListResponse,\n  GetOneResponse,\n  UpdateResponse,\n} from \"@refinedev/core\";\nimport PocketBase from \"pocketbase\";\nimport {\n  extractFilterExpression,\n  extractFilterValues,\n  isClientResponseError,\n  toHttpError,\n} from \"./utils\";\n\nexport const dataProvider = (\n  pb: PocketBase\n): Omit<\n  Required<DataProvider>,\n  \"createMany\" | \"updateMany\" | \"deleteMany\" | \"custom\" | \"getMany\"\n> => ({\n  getList: async ({ resource, pagination, filters, sorters }) => {\n    const { current = 1, pageSize = 10, mode = \"server\" } = pagination ?? {};\n\n    const sort = sorters\n      ?.map((s) => `${s.order === \"desc\" ? \"-\" : \"\"}${s.field}`)\n      .join(\",\");\n\n    const filter = filters\n      ? pb.filter(\n          extractFilterExpression(filters),\n          extractFilterValues(filters)\n        )\n      : undefined;\n\n    const collection = pb.collection(resource);\n\n    try {\n      if (mode === \"server\") {\n        const { items, totalItems } = await collection.getList(\n          current,\n          pageSize,\n          {\n            ...(sort ? { sort } : {}),\n            ...(filter ? { filter } : {}),\n            requestKey: null,\n          }\n        );\n\n        return {\n          data: items,\n          total: totalItems,\n        } as GetListResponse<any>;\n      } else {\n        const items = await collection.getFullList({\n          sort,\n          filter,\n          requestKey: null,\n        });\n\n        return {\n          data: items,\n          total: items.length,\n        } as GetListResponse<any>;\n      }\n    } catch (e: unknown) {\n      if (isClientResponseError(e)) {\n        throw toHttpError(e);\n      }\n      throw e;\n    }\n  },\n\n  create: async ({ resource, variables }) => {\n    try {\n      const data = await pb\n        .collection(resource)\n        .create(variables as Record<string, unknown>, { requestKey: null });\n\n      return { data } as CreateResponse<any>;\n    } catch (e: unknown) {\n      if (isClientResponseError(e)) {\n        throw toHttpError(e);\n      }\n      throw e;\n    }\n  },\n\n  update: async ({ resource, id, variables }) => {\n    try {\n      const data = await pb\n        .collection(resource)\n        .update(id as string, variables as Record<string, unknown>, {\n          requestKey: null,\n        });\n\n      return { data } as UpdateResponse<any>;\n    } catch (e: unknown) {\n      if (isClientResponseError(e)) {\n        throw toHttpError(e);\n      }\n      throw e;\n    }\n  },\n\n  getOne: async ({ resource, id }) => {\n    try {\n      const data = await pb\n        .collection(resource)\n        .getOne(id as string, { requestKey: null });\n\n      return { data } as GetOneResponse<any>;\n    } catch (e: unknown) {\n      if (isClientResponseError(e)) {\n        throw toHttpError(e);\n      }\n      throw e;\n    }\n  },\n\n  deleteOne: async ({ resource, id }) => {\n    try {\n      const deleted = await pb\n        .collection(resource)\n        .delete(id as string, { requestKey: null });\n\n      return { data: deleted ? { id } : undefined } as any;\n    } catch (e) {\n      if (isClientResponseError(e)) {\n        throw toHttpError(e);\n      }\n      throw e;\n    }\n  },\n\n  getApiUrl: () => {\n    return pb.baseUrl;\n  },\n});\n","import { LiveEvent, LiveProvider } from \"@refinedev/core\";\nimport PocketBase, { UnsubscribeFunc } from \"pocketbase\";\n\nexport const liveProvider = (pb: PocketBase): LiveProvider => ({\n  subscribe: ({ channel, params, callback }) => {\n    return pb\n      .collection(channel.replace(\"resources/\", \"\"))\n      .subscribe(params?.id?.toString() ?? \"*\", (e) => {\n        const liveEvent: LiveEvent = {\n          channel,\n          date: new Date(),\n          payload: e.record,\n          type: e.action,\n        };\n\n        callback(liveEvent);\n      });\n  },\n  unsubscribe: (unsubscribeFn: Promise<UnsubscribeFunc>) => {\n    unsubscribeFn.then((unsub) => unsub());\n  },\n});\n"],"names":[],"version":3,"file":"index.mjs.map","sourceRoot":"../../"}