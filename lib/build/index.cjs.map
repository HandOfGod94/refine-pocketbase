{"mappings":"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","sources":["src/index.ts","src/authProvider.ts","src/dataProvider.ts","src/liveProvider.ts"],"sourcesContent":["export * from \"./authProvider\";\nexport * from \"./dataProvider\";\nexport * from \"./liveProvider\";\n","import { AuthBindings } from \"@refinedev/core\";\nimport type PocketBase from \"pocketbase\";\n\nexport interface LoginWithProvider {\n  providerName: string;\n}\nexport interface LoginWithPassword {\n  email: string;\n  password: string;\n  remember: boolean;\n}\n\ntype LoginOptions = LoginWithProvider | LoginWithPassword;\n\nconst isLoginWithProvider = (x: any): x is LoginWithProvider =>\n  typeof x.providerName === \"string\";\n\nexport const authProvider = (\n  pb: PocketBase,\n  options = {\n    loginRedirectTo: \"/\",\n    loginErrorRedirectTo: undefined,\n    logoutRedirectTo: \"/login\",\n    checkRedirectTo: \"/login\",\n  }\n): AuthBindings => ({\n  login: async (loginOptions: LoginOptions) => {\n    if (isLoginWithProvider(loginOptions)) {\n      await pb\n        .collection(\"users\")\n        .authWithOAuth2({ provider: loginOptions.providerName })\n        .catch(() => null);\n      if (pb.authStore.isValid) {\n        return {\n          success: true,\n          redirectTo: options.loginRedirectTo,\n        };\n      }\n    } else {\n      await pb\n        .collection(\"users\")\n        .authWithPassword(loginOptions.email, loginOptions.password)\n        .catch(() => null);\n      if (pb.authStore.isValid) {\n        return {\n          success: true,\n          redirectTo: options.loginRedirectTo,\n        };\n      }\n    }\n\n    return {\n      success: false,\n      error: {\n        name: \"Login error\",\n        message: \"Invalid credentials\",\n      },\n      redirectTo: options.loginErrorRedirectTo,\n    };\n  },\n  logout: async () => {\n    pb.authStore.clear();\n    return {\n      success: true,\n      redirectTo: options.logoutRedirectTo,\n    };\n  },\n  check: async () => {\n    if (pb.authStore.isValid) {\n      return {\n        authenticated: true,\n      };\n    }\n\n    return {\n      authenticated: false,\n      redirectTo: options.checkRedirectTo,\n    };\n  },\n  getPermissions: async () => null,\n  getIdentity: async () => {\n    if (pb.authStore.isValid && pb.authStore.model) {\n      const { id, name, avatar } = pb.authStore.model;\n      return {\n        id,\n        name,\n        avatar,\n      };\n    }\n    return null;\n  },\n  onError: async (error) => {\n    return { error };\n  },\n});\n","import {\n  ConditionalFilter,\n  CrudFilter,\n  CrudFilters,\n  DataProvider,\n  HttpError,\n} from \"@refinedev/core\";\nimport PocketBase, { ClientResponseError } from \"pocketbase\";\n\nexport const dataProvider = (\n  pb: PocketBase\n): Omit<\n  Required<DataProvider>,\n  \"createMany\" | \"updateMany\" | \"deleteMany\" | \"custom\" | \"getMany\"\n> => ({\n  getList: async ({ resource, pagination, filters, sorters }) => {\n    const { current = 1, pageSize = 10, mode = \"server\" } = pagination ?? {};\n\n    const sort = sorters\n      ?.map((s) => `${s.order === \"desc\" ? \"-\" : \"\"}${s.field}`)\n      .join(\",\");\n\n    const filter = filters\n      ? pb.filter(\n          extractFilterExpression(filters),\n          extractFilterValues(filters)\n        )\n      : undefined;\n\n    const collection = pb.collection(resource);\n\n    if (mode === \"server\") {\n      const { items, totalItems } = await collection.getList(\n        current,\n        pageSize,\n        { sort, filter }\n      );\n\n      return {\n        data: items as any,\n        total: totalItems,\n      };\n    } else {\n      const items = await collection.getFullList({ sort, filter });\n\n      return {\n        data: items,\n        total: items.length,\n      };\n    }\n  },\n\n  create: async ({ resource, variables }) => {\n    try {\n      const data = await pb\n        .collection(resource)\n        .create(variables as Record<string, unknown>, { requestKey: null });\n\n      return { data } as any;\n    } catch (e: unknown) {\n      if (isClientResponseError(e)) {\n        throw toHttpError(e);\n      }\n      throw e;\n    }\n  },\n\n  update: async ({ resource, id, variables }) => {\n    try {\n      const data = await pb\n        .collection(resource)\n        .update(id as string, variables as Record<string, any>);\n\n      return { data } as any;\n    } catch (e: unknown) {\n      if (isClientResponseError(e)) {\n        throw toHttpError(e);\n      }\n      throw e;\n    }\n  },\n\n  getOne: async ({ resource, id }) => {\n    const data = await pb.collection(resource).getOne(id as string);\n\n    return { data } as any;\n  },\n\n  deleteOne: async ({ resource, id }) => {\n    const deleted = await pb.collection(resource).delete(id as string);\n\n    return { data: deleted ? { id } : undefined } as any;\n  },\n\n  getApiUrl: () => {\n    return pb.baseUrl;\n  },\n});\n\nconst OPERATOR_MAP = {\n  eq: \"=\",\n  ne: \"!=\",\n  lt: \"<\",\n  gt: \">\",\n  lte: \"<=\",\n  gte: \">=\",\n  in: \"?=\",\n  nin: \"?!=\",\n  contains: \"~\",\n  ncontains: \"!~\",\n  containss: \"~\",\n  ncontainss: \"!~\",\n  between: \"\",\n  nbetween: \"\",\n  null: \"=\",\n  nnull: \"!=\",\n  startswith: \"~\",\n  nstartswith: \"!~\",\n  startswiths: \"~\",\n  nstartswiths: \"!~\",\n  endswith: \"~\",\n  nendswith: \"!~\",\n  endswiths: \"~\",\n  nendswiths: \"!~\",\n  or: \"||\",\n  and: \"&&\",\n};\n\nconst isClientResponseError = (x: any): x is ClientResponseError =>\n  typeof x.response === \"object\";\n\nconst toHttpError = (e: ClientResponseError): HttpError => ({\n  message: e.message,\n  statusCode: e.status,\n  errors: Object.keys(e.response.data).reduce(\n    (acc, next) => ({\n      ...acc,\n      [next]: (e as ClientResponseError).response.data[next].message,\n    }),\n    {}\n  ),\n});\n\nconst isConditionalFilter = (filter: CrudFilter): filter is ConditionalFilter =>\n  filter.operator === \"and\" || filter.operator === \"or\";\n\nexport const extractFilterExpression = (\n  filters: CrudFilters,\n  joinOperator: ConditionalFilter[\"operator\"] = \"and\",\n  pos = 0\n) =>\n  filters\n    .map((filter, i): string =>\n      isConditionalFilter(filter)\n        ? `(${extractFilterExpression(filter.value, filter.operator, i)})`\n        : `${filter.field} ${OPERATOR_MAP[filter.operator]} {:${\n            filter.field\n          }${pos}${i}}`\n    )\n    .join(` ${OPERATOR_MAP[joinOperator]} `);\n\nexport const extractFilterValues = (\n  filters: CrudFilters,\n  pos = 0\n): Record<string, unknown> =>\n  filters.reduce(\n    (acc, filter, i) => ({\n      ...acc,\n      ...(isConditionalFilter(filter)\n        ? extractFilterValues(filter.value, i)\n        : { [filter.field + pos + i]: filter.value }),\n    }),\n    {}\n  );\n","import { LiveEvent, LiveProvider } from \"@refinedev/core\";\nimport PocketBase, { UnsubscribeFunc } from \"pocketbase\";\n\nexport const liveProvider = (pb: PocketBase): LiveProvider => ({\n  subscribe: ({ channel, params, callback }) => {\n    return pb\n      .collection(channel.replace(\"resources/\", \"\"))\n      .subscribe(params?.id?.toString() ?? \"*\", (e) => {\n        const liveEvent: LiveEvent = {\n          channel,\n          date: new Date(),\n          payload: e.record,\n          type: e.action,\n        };\n\n        callback(liveEvent);\n      });\n  },\n  unsubscribe: (unsubscribeFn: Promise<UnsubscribeFunc>) => {\n    unsubscribeFn.then((unsub) => unsub());\n  },\n});\n"],"names":[],"version":3,"file":"index.cjs.map","sourceRoot":"../"}